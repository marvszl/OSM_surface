<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>OSM Straßenfilter by Meinsware</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body, html { margin: 0; padding: 0; height: 100%; }
    #map { width: 100%; height: 100%; }

    #toggleButtons {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1100;
      display: flex;
      gap: 5px;
      flex-wrap: wrap;
    }
    #toggleButtons button {
      background: #0078A8;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    #filter, #legendBox, #searchArea {
      position: absolute;
      z-index: 1000;
      background: white;
      padding: 10px;
      border-radius: 6px;
      box-shadow: 0 0 5px rgba(0,0,0,0.3);
      font-family: sans-serif;
      font-size: 14px;
      min-width: 240px;
      max-height: 90%;
      overflow: auto;
      transition: all 0.3s ease;
    }
    #filter {
      top: 50px;
      right: 10px;
      display: none;
    }
    #legendBox {
      bottom: 10px;
      left: 10px;
      display: none;
      font-size: 13px;
    }
    #searchArea {
      top: 10px;
      left: 50px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 5px;
    }
    .hidden {
      opacity: 0;
      transform: scale(0.95);
      pointer-events: none;
    }

    #searchArea input, #searchArea select {
      width: 220px;
      font-size: 14px;
      padding: 4px;
    }
    #searchArea button {
      background: #0078A8;
      color: white;
      border: none;
      padding: 5px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    #filter label {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
    }
    .color-box {
      width: 16px;
      height: 16px;
      margin-right: 6px;
      display: inline-block;
      border: 1px solid #000;
    }

    #zoomLevel {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 1200;
      background: rgba(255,255,255,0.8);
      padding: 5px 10px;
      border-radius: 6px;
      font-family: sans-serif;
      font-size: 13px;
      box-shadow: 0 0 5px rgba(0,0,0,0.3);
    }

    /* Ladeanimation */
    #loadingOverlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(255, 255, 255, 0.7);
      display: none;
      z-index: 2000;
      align-items: center;
      justify-content: center;
      font-family: sans-serif;
      font-size: 18px;
    }

    #loadingSpinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #0078A8;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin-bottom: 10px;
    }
    @keyframes spin {
      0% { transform: rotate(0deg);}
      100% { transform: rotate(360deg);}
    }
  </style>
</head>
<body>

  <div id="toggleButtons">
    <button onclick="locateUser()">📍 Ich</button>
    <button onclick="findRandomLandPoint()">🎲 Punkt</button>
    <button onclick="toggleSearchArea()">🔍 Suche</button>
    <button onclick="toggleFilter()">🛠️ Filter</button>
    <button onclick="toggleLegend()">📜 Legende</button>
    <button onclick="loadData()">↻ Neu laden</button>
    <button onclick="clearMarkers()">🗑️ Markierungen</button>
    <button onclick="resetMap()">🔄 Zurücksetzen</button>
  </div>

<div id="searchArea">
  <input type="text" id="searchInput" placeholder="Ort oder Stadt suchen">
  <div style="display: flex; gap: 5px;">
    <button onclick="searchLocation()">🔍 Suchen</button>
    <button onclick="clearSearch()">🗑️ Löschen</button>
  </div>

  <select id="results" onchange="selectLocation()" style="display:none;"></select>

  <hr style="margin:10px 0; width:100%;">

  <input type="text" id="coordInput" placeholder="z.B. 47.086987,15.541183">
  <div style="display: flex; gap: 5px; margin-top:5px;">
    <button onclick="goToCoordinates()">🧭 Gehe zu Koordinaten</button>
  </div>
</div>

<!-- Erweiterte Filterbox -->
<div id="filter">
  <strong>Oberfläche filtern:</strong><br>

  <!-- Bekannt aus deiner bisherigen Liste -->
  <label><span class="color-box" style="background:black;"></span><input type="checkbox" value="asphalt" checked> Asphalt</label>
  <label><span class="color-box" style="background:brown;"></span><input type="checkbox" value="gravel" checked> Schotter</label>
  <label><span class="color-box" style="background:gray;"></span><input type="checkbox" value="unpaved" checked> Unbefestigt</label>
  <label><span class="color-box" style="background:saddlebrown;"></span><input type="checkbox" value="dirt" checked> Erde</label>
  <label><span class="color-box" style="background:green;"></span><input type="checkbox" value="paved" checked> Gepflastert</label>
  <label><span class="color-box" style="background:orange;"></span><input type="checkbox" value="compacted" checked> Verdichtet</label>
  <label><span class="color-box" style="background:blue;"></span><input type="checkbox" value="unbekannt" checked> Unbekannt</label>

  <!-- NEU hinzugefügt -->
  <label><span class="color-box" style="background:lightgreen;"></span><input type="checkbox" value="grass"> Gras</label>
  <label><span class="color-box" style="background:burlywood;"></span><input type="checkbox" value="ground"> Naturboden</label>
  <label><span class="color-box" style="background:khaki;"></span><input type="checkbox" value="sand"> Sand</label>
  <label><span class="color-box" style="background:peru;"></span><input type="checkbox" value="mud"> Schlamm</label>
  <label><span class="color-box" style="background:tan;"></span><input type="checkbox" value="wood"> Holz</label>
  <label><span class="color-box" style="background:lightgray;"></span><input type="checkbox" value="concrete"> Beton</label>
  <label><span class="color-box" style="background:lightgray;"></span><input type="checkbox" value="concrete:plates"> Betonplatten</label>
  <label><span class="color-box" style="background:darkgray;"></span><input type="checkbox" value="cobblestone"> Kopfsteinpflaster</label>
  <label><span class="color-box" style="background:darkgray;"></span><input type="checkbox" value="cobblestone:flattened"> Flaches Pflaster</label>
  <label><span class="color-box" style="background:darkgray;"></span><input type="checkbox" value="paving_stones"> Pflastersteine</label>
  <label><span class="color-box" style="background:darkgray;"></span><input type="checkbox" value="sett"> Rechteckpflaster</label>
  <label><span class="color-box" style="background:silver;"></span><input type="checkbox" value="metal"> Metall</label>
  <label><span class="color-box" style="background:sienna;"></span><input type="checkbox" value="woodchips"> Hackschnitzel</label>
  <label><span class="color-box" style="background:lightblue;"></span><input type="checkbox" value="ice"> Eis</label>
  <label><span class="color-box" style="background:whitesmoke;"></span><input type="checkbox" value="snow"> Schnee</label>
  <label><span class="color-box" style="background:lightgray;"></span><input type="checkbox" value="pebblestone"> Kieselsteine</label>

</div>

<!-- Erweiterte Legendenbox -->
<div id="legendBox">
  <div><span class="color-box" style="background:black;"></span> Asphalt</div>
  <div><span class="color-box" style="background:brown;"></span> Schotter (gravel)</div>
  <div><span class="color-box" style="background:gray;"></span> Unbefestigt (unpaved)</div>
  <div><span class="color-box" style="background:saddlebrown;"></span> Erde (dirt)</div>
  <div><span class="color-box" style="background:green;"></span> Gepflastert (paved)</div>
  <div><span class="color-box" style="background:orange;"></span> Verdichtet (compacted)</div>
  <div><span class="color-box" style="background:blue;"></span> Unbekannt (kein surface-Tag)</div>

  <!-- Neu -->
  <div><span class="color-box" style="background:lightgreen;"></span> Gras</div>
  <div><span class="color-box" style="background:burlywood;"></span> Naturboden</div>
  <div><span class="color-box" style="background:khaki;"></span> Sand</div>
  <div><span class="color-box" style="background:peru;"></span> Schlamm</div>
  <div><span class="color-box" style="background:tan;"></span> Holz</div>
  <div><span class="color-box" style="background:lightgray;"></span> Beton</div>
  <div><span class="color-box" style="background:lightgray;"></span> Betonplatten</div>
  <div><span class="color-box" style="background:darkgray;"></span> Kopfsteinpflaster</div>
  <div><span class="color-box" style="background:darkgray;"></span> Flaches Pflaster</div>
  <div><span class="color-box" style="background:darkgray;"></span> Pflastersteine</div>
  <div><span class="color-box" style="background:darkgray;"></span> Rechteckpflaster</div>
  <div><span class="color-box" style="background:silver;"></span> Metall</div>
  <div><span class="color-box" style="background:sienna;"></span> Hackschnitzel</div>
  <div><span class="color-box" style="background:lightblue;"></span> Eis</div>
  <div><span class="color-box" style="background:whitesmoke;"></span> Schnee</div>
  <div><span class="color-box" style="background:lightgray;"></span> Kieselsteine</div>
</div>

<div id="map"></div>
<div id="zoomLevel">Zoom: 10</div>
<div id="loadingOverlay">
  
  <div id="loadingSpinner"></div>
  Lädt Daten...
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
// Hier kommt gleich dein vollständiges neues JavaScript rein!
// 👉 Sag einfach "weiter", dann schicke ich Teil 2 sofort nach!

const map = L.map('map').setView([48.2583, 13.0333], 10);
const startPosition = [48.2583, 13.0333];
const startZoom = 10;

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '&copy; OpenStreetMap-Mitwirkende'
}).addTo(map);

let currentLayer;
let searchResults = [];
let marker;
let filterVisible = true;
let legendVisible = false;
let searchVisible = true;

// Suchbereich ein-/ausblenden
function toggleSearchArea() {
  const searchArea = document.getElementById('searchArea');
  if (searchVisible) {
    searchArea.classList.add('hidden');
    setTimeout(() => searchArea.style.display = 'none', 300);
  } else {
    searchArea.style.display = 'flex';
    setTimeout(() => searchArea.classList.remove('hidden'), 10);
  }
  searchVisible = !searchVisible;
}

// Filter ein-/ausblenden
function toggleFilter() {
  const filter = document.getElementById('filter');
  if (filterVisible) {
    filter.classList.add('hidden');
    setTimeout(() => filter.style.display = 'none', 300);
  } else {
    filter.style.display = 'block';
    setTimeout(() => filter.classList.remove('hidden'), 10);
  }
  filterVisible = !filterVisible;
}

//***************************

function locateUser() {
  if (!navigator.geolocation) {
    alert("Dein Browser unterstützt keine Standortabfrage.");
    return;
  }

  navigator.geolocation.getCurrentPosition(position => {
    const lat = position.coords.latitude;
    const lon = position.coords.longitude;

    map.setView([lat, lon], 14); // Zoom auf Nutzerposition

    L.marker([lat, lon]).addTo(map)
      .bindPopup("📍 Dein aktueller Standort")
      .openPopup();

  }, error => {
    alert("Standort konnte nicht ermittelt werden.");
    console.error(error);
  });
}

//***************************

async function findRandomLandPoint() {
  const maxTries = 10;
  let tries = 0;

  const loadingOverlay = document.getElementById('loadingOverlay');
  loadingOverlay.style.display = "flex";

  while (tries < maxTries) {
    // Update Ladeanzeige
    loadingOverlay.innerHTML = `
      <div id="loadingSpinner"></div>
      Suche zufälligen Punkt...<br>🔁 Versuch ${tries + 1} von ${maxTries}
    `;

    const lat = Math.random() * 170 - 85;
    const lon = Math.random() * 360 - 180;

    try {
      // Reverse-Geocoding für Land
      const reverseUrl = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lon}`;
      const reverseResponse = await fetch(reverseUrl, { headers: { 'Accept-Language': 'de' } });
      const reverseData = await reverseResponse.json();

      if (reverseData.address && reverseData.address.country) {
        const country = reverseData.address.country;
        console.log("Gefundenes Land:", country);

        // Suche Flughäfen im Land
        const overpassQuery = `
          [out:json][timeout:25];
          area["name"="${country}"]->.searchArea;
          (
            node["aeroway"="airport"](area.searchArea);
          );
          out body;
        `;
        const overpassUrl = "https://overpass-api.de/api/interpreter";
        const overpassResponse = await fetch(overpassUrl, {
          method: "POST",
          body: overpassQuery,
          headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' }
        });

        const airportData = await overpassResponse.json();

        if (airportData.elements && airportData.elements.length > 0) {
          // Versuche einen Flughafen mit IATA-Code zu finden
          const airportWithIATA = airportData.elements.find(el => el.tags && el.tags.iata);

          let selectedAirport = airportWithIATA || airportData.elements[0];

          const airportLat = selectedAirport.lat;
          const airportLon = selectedAirport.lon;
          const airportName = selectedAirport.tags.name || "Unbekannter Flughafen";
          const iataCode = selectedAirport.tags.iata || "IATA-Code unbekannt";

          if (marker) {
            map.removeLayer(marker);
          }

          map.setView([airportLat, airportLon], 10);

          marker = L.marker([airportLat, airportLon]).addTo(map);
          marker.bindPopup(`
            ✈️ <strong>${iataCode} – ${airportName}</strong><br><br>
            📍 Koordinaten: ${airportLat.toFixed(5)}, ${airportLon.toFixed(5)}<br>
            🏳️ Land: ${country}
          `).openPopup();

          loadingOverlay.style.display = "none";

          // ✅ Erfolgsmeldung kurz einblenden
          showSuccessMessage("✅ Flughafen gefunden!");
          return;
        }
      }
    } catch (err) {
      console.error("Fehler bei Abfrage:", err);
    }

    tries++;
  }

  loadingOverlay.style.display = "none";
  alert("Kein passender Flughafen gefunden. Bitte erneut versuchen.");
}
//***************************

 function showSuccessMessage(text) {
  const successDiv = document.createElement("div");
  successDiv.style.position = "fixed";
  successDiv.style.top = "20px";
  successDiv.style.left = "50%";
  successDiv.style.transform = "translateX(-50%)";
  successDiv.style.background = "#28a745";
  successDiv.style.color = "white";
  successDiv.style.padding = "10px 20px";
  successDiv.style.borderRadius = "6px";
  successDiv.style.fontFamily = "sans-serif";
  successDiv.style.fontSize = "16px";
  successDiv.style.boxShadow = "0 0 10px rgba(0,0,0,0.3)";
  successDiv.style.zIndex = 5000;
  successDiv.innerText = text;
  document.body.appendChild(successDiv);

  setTimeout(() => {
    successDiv.remove();
  }, 2500);
}
 
  
//***************************
function goToCoordinates() {
  const input = document.getElementById('coordInput').value.trim();
  
  if (!input.includes(",")) {
    alert("Bitte Koordinaten im Format: Breite, Länge eingeben!");
    return;
  }

  const parts = input.split(",");
  if (parts.length !== 2) {
    alert("Bitte genau zwei Werte eingeben: Breite und Länge, getrennt durch Komma.");
    return;
  }

  const lat = parseFloat(parts[0]);
  const lon = parseFloat(parts[1]);

  if (isNaN(lat) || isNaN(lon)) {
    alert("Ungültige Zahlenangabe. Bitte überprüfe die Koordinaten.");
    return;
  }

  if (lat < -90 || lat > 90 || lon < -180 || lon > 180) {
    alert("Ungültige Werte: Breite muss zwischen -90 und 90, Länge zwischen -180 und 180 liegen.");
    return;
  }

  // Setze Karte
  map.setView([lat, lon], 14);

  // Setze Marker
  if (marker) {
    map.removeLayer(marker);
  }
  marker = L.marker([lat, lon]).addTo(map);
}

// Karte: Klick für Marker mit kopierbaren Koordinaten
map.on('click', function(e) {
  const { lat, lng } = e.latlng;

  if (marker) {
    map.removeLayer(marker);
  }

  marker = L.marker([lat, lng]).addTo(map);

  const coords = `${lat.toFixed(14)}, ${lng.toFixed(14)}`;

  const popupContent = `
    <div style="display: flex; align-items: center; gap: 5px;">
      <span id="coordText">${coords}</span>
      <button onclick="copyCoordinates()" title="Kopieren" style="background:none; border:none; cursor:pointer;">📋</button>
    </div>
  `;

  marker.bindPopup(popupContent).openPopup();
});

// Funktion: Koordinaten kopieren
function copyCoordinates() {
  const coordText = document.getElementById('coordText').innerText;
  navigator.clipboard.writeText(coordText).then(() => {
    alert("Koordinaten kopiert!");
  }).catch(err => {
    console.error("Fehler beim Kopieren:", err);
  });
}

// Legende ein-/ausblenden
function toggleLegend() {
  const legend = document.getElementById('legendBox');
  if (legendVisible) {
    legend.classList.add('hidden');
    setTimeout(() => legend.style.display = 'none', 300);
  } else {
    legend.style.display = 'block';
    setTimeout(() => legend.classList.remove('hidden'), 10);
  }
  legendVisible = !legendVisible;
}

// Markierungen löschen
function clearMarkers() {
  if (currentLayer) {
    map.removeLayer(currentLayer);
    currentLayer = null;
  }
  if (marker) {
    map.removeLayer(marker);
    marker = null;
  }
}

// Karte zurücksetzen
function resetMap() {
  clearMarkers();
  map.setView(startPosition, startZoom);
}

// Suche ausführen
async function searchLocation() {
  const input = document.getElementById('searchInput').value.trim();
  const results = document.getElementById('results');

  if (!input) {
    alert("Bitte gib einen Ort oder eine Stadt ein.");
    return;
  }

  const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(input)}`;

  try {
    const response = await fetch(url, { headers: { 'Accept-Language': 'de' } });
    const data = await response.json();

    if (data.length === 0) {
      alert("Kein Ort gefunden.");
      return;
    }

    searchResults = data;
    results.innerHTML = "";

    if (data.length === 1) {
      centerMap(data[0]);
      results.style.display = "none";
    } else {
      data.forEach((place, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.text = place.display_name;
        results.appendChild(option);
      });
      results.style.display = "block";
    }
  } catch (error) {
    console.error("Fehler bei der Suche:", error);
    alert("Fehler bei der Suche. Bitte versuche es später nochmal.");
  }
}

// Suchergebnis auswählen
function selectLocation() {
  const results = document.getElementById('results');
  const selectedIndex = results.value;
  const selectedPlace = searchResults[selectedIndex];
  if (selectedPlace) {
    centerMap(selectedPlace);
  }
}

// Marker setzen
function centerMap(place) {
  const lat = parseFloat(place.lat);
  const lon = parseFloat(place.lon);
  map.setView([lat, lon], 12);

  if (marker) {
    map.removeLayer(marker);
  }
  marker = L.marker([lat, lon]).addTo(map);
}

// Suchfeld leeren
function clearSearch() {
  document.getElementById('searchInput').value = "";
  const results = document.getElementById('results');
  results.style.display = "none";
  results.innerHTML = "";

  if (marker) {
    map.removeLayer(marker);
    marker = null;
  }
}

// Oberflächenfilter holen
function getSelectedSurfaces() {
  return Array.from(document.querySelectorAll('#filter input[type=checkbox]:checked'))
              .map(cb => cb.value);
}

// Overpass-Abfrage erstellen
function buildOverpassQuery(selectedSurfaces) {
  if (selectedSurfaces.length === 0) return null;

  const bbox = map.getBounds();
  const south = bbox.getSouth();
  const west = bbox.getWest();
  const north = bbox.getNorth();
  const east = bbox.getEast();

  const knownSurfaces = selectedSurfaces.filter(s => s !== "unbekannt");
  const includeUnknown = selectedSurfaces.includes("unbekannt");

  let queryParts = [];

  if (knownSurfaces.length > 0) {
    const surfaceFilter = knownSurfaces.join('|');
    queryParts.push(`way["highway"]["surface"~"${surfaceFilter}"](${south},${west},${north},${east});`);
  }

  if (includeUnknown) {
    queryParts.push(`way["highway"]["surface"!~"."](${south},${west},${north},${east});`);
  }

  return `
    [out:json][timeout:25];
    (
      ${queryParts.join('\n')}
    );
    out geom;
  `;
}

// Straßen laden
async function loadData() {
  const loadingOverlay = document.getElementById('loadingOverlay');

  const currentZoom = map.getZoom();
  if (currentZoom < 13) {
    alert("Bitte näher heranzoomen! Mindest-Zoomstufe für Datenabruf: 13");
    return;
  }

  loadingOverlay.style.display = "flex";

  const surfaces = getSelectedSurfaces();
  const query = buildOverpassQuery(surfaces);
  if (!query) {
    alert("Bitte mindestens eine Oberfläche auswählen.");
    loadingOverlay.style.display = "none";
    return;
  }

  const servers = [
    "https://overpass.kumi.systems/api/interpreter",
    "https://overpass-api.de/api/interpreter"
  ];

  let data = null;

  for (let server of servers) {
    try {
      const response = await fetch(server, {
        method: "POST",
        body: query,
        headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8' }
      });
      const text = await response.text();
      data = JSON.parse(text);
      break;
    } catch (error) {
      console.error("Fehler bei Server:", server, error);
    }
  }

  if (!data) {
    alert("Fehler: Keine gültigen Daten von Overpass-Server erhalten.");
    loadingOverlay.style.display = "none";
    return;
  }

  const geojson = overpassToGeoJSON(data);

  if (currentLayer) map.removeLayer(currentLayer);

  currentLayer = L.geoJSON(geojson, {
    style: feature => ({
      color: surfaceColor(feature.properties.surface),
      weight: 3
    })
  }).addTo(map);

  loadingOverlay.style.display = "none";
}

// Overpass Daten in GeoJSON konvertieren
function overpassToGeoJSON(data) {
  const features = data.elements
    .filter(el => el.type === 'way' && el.geometry)
    .map(way => ({
      type: "Feature",
      properties: {
        id: way.id,
        surface: way.tags?.surface || 'unbekannt'
      },
      geometry: {
        type: "LineString",
        coordinates: way.geometry.map(p => [p.lon, p.lat])
      }
    }));
  return {
    type: "FeatureCollection",
    features: features
  };
}

// Farben für Oberflächen
function surfaceColor(type) {
  const colors = {
    asphalt: "black",
    gravel: "brown",
    unpaved: "gray",
    dirt: "saddlebrown",
    paved: "green",
    compacted: "orange",
    unbekannt: "blue",
    grass: "lightgreen",
    ground: "burlywood",
    sand: "khaki",
    mud: "peru",
    wood: "tan",
    concrete: "lightgray",
    "concrete:plates": "lightgray",
    cobblestone: "darkgray",
    "cobblestone:flattened": "darkgray",
    paving_stones: "darkgray",
    sett: "darkgray",
    metal: "silver",
    woodchips: "sienna",
    ice: "lightblue",
    snow: "whitesmoke",
    pebblestone: "lightgray"
  };
  return colors[type] || "blue";
}

// Zoomlevel-Anzeige aktualisieren
function updateZoomLevel() {
  const zoomDisplay = document.getElementById('zoomLevel');
  zoomDisplay.innerText = "Zoom: " + map.getZoom();
}

map.on('zoomend', updateZoomLevel);

window.onload = () => {
  document.getElementById('searchInput').focus();
  updateZoomLevel();
};

</script>

</body>
</html>
